<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
        }

        #visualization {
            width: 100%;
            height: 100%;
            position: relative;
            background-color: #1a1a1a;
        }

        #lossDisplay {
            position: absolute;
            top: 20px; /* Adjust positioning relative to the neural network diagram */
            right: 20px; /* Adjust positioning relative to the neural network diagram */
            z-index: 10;
            background-color: transparent; /* Make the background transparent */
            border: 2px solid white; /* Add a white outline */
            padding: 20px; /* Increase padding for a bigger box */
            border-radius: 8px;
            color: #ffffff;
            font-size: 16px;
            font-weight: bold;
            text-align: center; /* Center the text within the box */
            pointer-events: none; /* Ensure the box doesn't interfere with interactions */
        }

        circle {
            stroke: #ddd;
            fill: none;
            stroke-width: 20;
            cursor: pointer;
            pointer-events: all;
        }

        line {
            stroke: #ccc;
            stroke-width: 3;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div id="controls">
        <label for="inputNodes">Input Nodes:</label>
        <input type="number" id="inputNodes" value="3" min="1">

        <label for="hiddenLayers">Hidden Layers:</label>
        <input type="text" id="hiddenLayers" value="4,3">

        <label for="outputNodes">Output Nodes:</label>
        <input type="number" id="outputNodes" value="1" min="1">

        <label for="epochs">Epochs:</label>
        <input type="number" id="epochs" value="1000" min="1">

        <label for="learningRate">Learning Rate:</label>
        <input type="number" id="learningRate" value="0.01" step="0.001" min="0.001">

        <button id="loadNetworkBtn">Load Neural Network</button>
        <button id="trainNetworkBtn">Train Neural Network</button>
        <button id="stopTrainingBtn">Stop Training</button>
    </div>

    <div id="visualization"></div>
    <div id="lossDisplay">Loss: N/A</div> <!-- Loss display box -->

    <script>
        let stopTraining = false;

        document.getElementById('loadNetworkBtn').addEventListener('click', function() {
            const inputNodes = parseInt(document.getElementById('inputNodes').value);
            const hiddenLayers = document.getElementById('hiddenLayers').value.split(',').map(Number);
            const outputNodes = parseInt(document.getElementById('outputNodes').value);

            const layers = [inputNodes, ...hiddenLayers, outputNodes];
            drawNeuralNetwork(layers);
        });

        document.getElementById('trainNetworkBtn').addEventListener('click', function() {
            stopTraining = false;
            const epochs = parseInt(document.getElementById('epochs').value);
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            fetch('http://127.0.0.1:5000/train', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    inputNodes: parseInt(document.getElementById('inputNodes').value),
                    hiddenLayers: document.getElementById('hiddenLayers').value.split(',').map(Number),
                    outputNodes: parseInt(document.getElementById('outputNodes').value),
                    epochs: epochs,
                    learningRate: learningRate
                })
            })
            .then(response => response.json())
            .then(data => animateDataFlow(data))
            .catch(error => console.error('Error:', error));
        });

        document.getElementById('stopTrainingBtn').addEventListener('click', function() {
            stopTraining = true;
        });

        let nodes = [];

        function drawNeuralNetwork(layers) {
            d3.select("#visualization").html("");

            const width = window.innerWidth;
            const height = window.innerHeight;
            const svg = d3.select("#visualization").append("svg")
                .attr("width", width)
                .attr("height", height);

            const layerSpacing = width / (layers.length + 1);
            const nodeRadius = 20;

            nodes = [];

            layers.forEach((layerSize, layerIndex) => {
                const x = layerSpacing * (layerIndex + 1);
                const ySpacing = height / (layerSize + 1);

                for (let i = 0; i < layerSize; i++) {
                    const y = ySpacing * (i + 1);

                    const node = svg.append("circle")
                        .attr("cx", x)
                        .attr("cy", y)
                        .attr("r", nodeRadius)
                        .style("fill", "none")
                        .style("stroke", "white")
                        .style("stroke-width", "2")
                        .call(d3.drag()
                            .on("start", dragStarted)
                            .on("drag", dragged)
                            .on("end", dragEnded)
                        );

                    nodes.push({ layerIndex, i, x, y, node });
                }
            });

            nodes.forEach(sourceNode => {
                if (sourceNode.layerIndex > 0) {
                    const prevLayerNodes = nodes.filter(node => node.layerIndex === sourceNode.layerIndex - 1);

                    prevLayerNodes.forEach(targetNode => {
                        svg.append("line")
                            .attr("x1", targetNode.x)
                            .attr("y1", targetNode.y)
                            .attr("x2", sourceNode.x)
                            .attr("y2", sourceNode.y)
                            .attr("stroke", "#ccc")
                            .attr("stroke-width", 2)
                            .attr("class", `line-${sourceNode.layerIndex}-${sourceNode.i}-${targetNode.i}`);
                    });
                }
            });
        }

        function animateDataFlow(data) {
            const svg = d3.select("svg");

            data.forEach((epochData, epochIndex) => {
                setTimeout(() => {
                    if (stopTraining) return;

                    const forwardDuration = epochData.forward_data.forward_time * 30000;
                    const backwardDuration = epochData.backward_data.backward_time * 30000;

                    animateForwardPass(epochData.forward_data, svg, forwardDuration);
                    setTimeout(() => {
                        animateBackwardPass(epochData.backward_data, svg, backwardDuration);
                    }, forwardDuration + 500);

                    // Update the loss display
                    updateLossDisplay(epochData.loss);

                }, epochIndex * 1000);
            });
        }

        function animateForwardPass(forwardData, svg, duration) {
            forwardData.input.forEach((input, index) => {
                const inputNode = nodes.find(node => node.layerIndex === 0 && node.i === index);
                animateLightThroughLayer(inputNode, forwardData.hidden_activation, duration * 50, svg, "forward");
            });
        }

        function animateBackwardPass(backwardData, svg, duration) {
            const hiddenNodes = nodes.filter(node => node.layerIndex === 1);
            const outputNodes = nodes.filter(node => node.layerIndex === 2);

            outputNodes.forEach((outputNode, i) => {
                animateLightThroughLayer(outputNode, hiddenNodes, duration * 50, svg, "backward");
            });

            hiddenNodes.forEach((hiddenNode, i) => {
                animateLightThroughLayer(hiddenNode, nodes.filter(node => node.layerIndex === 0), duration * 50, svg, "backward");
            });
        }

        function animateLightThroughLayer(node, nextLayerData, duration, svg, direction) {
            const nextLayerNodes = nodes.filter(n => n.layerIndex === node.layerIndex + 1);

            nextLayerNodes.forEach((targetNode, i) => {
                const light = svg.append("circle")
                    .attr("cx", node.x)
                    .attr("cy", node.y)
                    .attr("r", 5)
                    .style("fill", "yellow")
                    .style("opacity", 1);

                light.transition()
                    .duration(duration)
                    .attr("cx", targetNode.x)
                    .attr("cy", targetNode.y)
                    .ease(d3.easeLinear)
                    .on("end", function() {
                        d3.select(this).remove();
                        if (direction === "forward" && node.layerIndex < nodes.length - 1) {
                            animateLightThroughLayer(targetNode, nextLayerData, duration, svg, "forward");
                        }
                    });
            });
        }

        function updateLossDisplay(loss) {
            document.getElementById('lossDisplay').textContent = `Loss: ${loss.toFixed(4)}`;
        }

        function dragStarted(event, d) {
            d3.select(this).raise().attr("stroke", "black");
        }

        function dragged(event, d) {
            d3.select(this)
                .attr("cx", event.x)
                .attr("cy", event.y);

            const draggedNode = nodes.find(n => n.node.node() === this);
            draggedNode.x = event.x;
            draggedNode.y = event.y;

            updateConnections(draggedNode);
        }

        function dragEnded(event, d) {
            d3.select(this).attr("stroke", "white");
        }

        function updateConnections(draggedNode) {
            nodes.forEach(targetNode => {
                if (targetNode.layerIndex === draggedNode.layerIndex - 1) {
                    d3.select(`.line-${draggedNode.layerIndex}-${draggedNode.i}-${targetNode.i}`)
                        .attr("x1", targetNode.x)
                        .attr("y1", targetNode.y)
                        .attr("x2", draggedNode.x)
                        .attr("y2", draggedNode.y);
                } else if (targetNode.layerIndex === draggedNode.layerIndex + 1) {
                    d3.select(`.line-${targetNode.layerIndex}-${targetNode.i}-${draggedNode.i}`)
                        .attr("x1", draggedNode.x)
                        .attr("y1", draggedNode.y)
                        .attr("x2", targetNode.x)
                        .attr("y2", targetNode.y);
                }
            });
        }
    </script>
</body>
</html>